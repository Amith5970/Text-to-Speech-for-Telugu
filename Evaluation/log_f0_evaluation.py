# -*- coding: utf-8 -*-
"""log_F0_EVALUATION.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19faZecXoZWQztOwV4hR3w667QSLFQGGI
"""

from google.colab import drive
drive.mount('/content/drive')

import os
import math
import glob
import librosa
import pyworld
import pysptk
import numpy as np
import matplotlib.pyplot as plot

ORIGINAL_PATH ='/content/drive/My Drive/TTS-40HRS/Test-files/TEST-FILES/resamplee_gt_wavs/'
SYNTHESIZED_PATH = '/content/drive/My Drive/TTS-40HRS/Test-files/TEST-FILES/vits/'

def load_wav(wav_file, sr):

    wav, _ = librosa.load(wav_file, sr=sr, mono=True)

    return wav

Org_paths = glob.glob(ORIGINAL_PATH+'/*')
Synth_paths = glob.glob(SYNTHESIZED_PATH+'/*')
Org_paths.sort()
Synth_paths.sort()
print(len(Org_paths))
print(len(Synth_paths))
for i in range(len(Org_paths)):
  print(i)
  assert os.path.basename(Org_paths[i])==os.path.basename(Synth_paths[i])
  #print(os.path.basename(Org_paths[i]),"   ",os.path.basename(Synth_paths[i]))
#print(Org_paths)

sampling_rate = 22050
num_mcep = 24
frame_period = 5.0
n_frames = 128
wavs_org=[]
wavs_synth=[]
print(len(Org_paths))
for i in range(len(Org_paths)):
  if os.path.basename(Org_paths[i])==os.path.basename(Synth_paths[i]):
    wavs_org.append(load_wav(wav_file = Org_paths[i], sr = sampling_rate))
    wavs_synth.append(load_wav(wav_file = Synth_paths[i], sr = sampling_rate))

print(len(wavs_org))

def world_encode_data(wavs, fs, frame_period = 5.0, coded_dim = 24):

    f0s = []
    log_f0s_concatenated0=[]
    num_mcep = 24
    for i in range(len(wavs)):
        wav = wavs[i]
        wav = wav.astype(np.float64)
        f0, _  = pyworld.harvest(wav, fs, frame_period = frame_period, f0_floor = 71.0, f0_ceil = 800.0)
        f0s.append(f0)
        log_f0s_concatenated0.append(np.ma.log(f0s[i]))
        #print(len(f0))


    return log_f0s_concatenated0 #f0s

f0s_org = world_encode_data(wavs = wavs_org, fs = sampling_rate, frame_period = frame_period, coded_dim = num_mcep)
f0s_synth = world_encode_data(wavs = wavs_synth, fs = sampling_rate, frame_period = frame_period, coded_dim = num_mcep)

min_cost_tot=[]
for i in range(len(wavs_org)):
  frame_len=0
  def logf0_rmse(x, y): # method to calculate cost
    #y=pad_to(y,len(x))
    log_spec_dB_const = 1/len(frame_len)
    # print(y)
    diff = x - y
    # print(x,"  ",y,"  ",len(y))
    # print(diff)
    #print(log_spec_dB_const * math.sqrt(np.inner(diff, diff)))
    return log_spec_dB_const * math.sqrt(np.inner(diff, diff))


  if len(f0s_org[i])<len(f0s_synth[i]):
    frame_len=f0s_org[i]
  else:
    frame_len=f0s_synth[i]

  cost_function = logf0_rmse
  min_cost, _ = librosa.sequence.dtw(f0s_org[i][:].T, f0s_synth[i][:].T,
                                                   metric=cost_function)
  #print(len(min_cost))

  min_cost_tot.append(np.mean(min_cost))

logF0RMSE=sum(min_cost_tot)/len(min_cost_tot)
print(f"logF0_RMSE = {logF0RMSE}")